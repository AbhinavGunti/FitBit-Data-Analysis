#importing necessary libraries

import numpy as np
import pandas as pd
import seaborn as sns
import streamlit as st
import io
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import MinMaxScaler
sns.set()
from sklearn.preprocessing import LabelEncoder, RobustScaler, StandardScaler
import matplotlib
import matplotlib.pyplot as plt
from scipy import stats
from sklearn.neighbors import KNeighborsClassifier as Knn
from sklearn.model_selection import train_test_split, GridSearchCV, StratifiedKFold
from sklearn.feature_selection import chi2
from sklearn.feature_selection import SelectKBest

import os
import warnings

warnings.filterwarnings('ignore') 
pd.set_option("display.precision", 2)
matplotlib.style.use('seaborn')

st.set_page_config(
        page_title="Fitbit Fitness Analysis",
        page_icon="heart"
        # layout="wide",
)
def get_info(df):
    buffer = io.StringIO()
    df.info(buf=buffer)
    st.text(buffer.getvalue())

from PIL import Image
image = Image.open('Fitbit-Logo-2016-present.jpg')
image = image.resize((300, 100))

with st.container():
    st.image(image)
    st.title("Fitbit Fitness Analysis")
head1, head2, head3,head4,head5,head6,head7= st.tabs(["About the data", "Data Exploration using Visualizations", "Cleaning and Processing","Analysis and Visualizations","Conclusions and Recommendations","Sleep Score Prediction","Heart Disease Prediction"])
# st.write("### Reading files")
@st.cache
def get_daily_activity():
    return pd.read_csv("dailyActivity_merged.csv")
@st.cache
def get_daily_sleep():
    return pd.read_csv("sleepDay_merged.csv")
@st.cache
def get_hourly_steps():
    return pd.read_csv("hourlySteps_merged.csv")
@st.cache
def get_heartrate_seconds():
    return pd.read_csv("heartrate_seconds_merged.csv")
@st.cache
def get_daily_steps():
    return pd.read_csv("dailySteps_merged.csv")
@st.cache
def get_weight_info():
    return pd.read_csv("weightLogInfo_merged.csv")
@st.cache
def get_heart():
    return pd.read_csv("heart.csv")
daily_activity1 = get_daily_activity()
daily_sleep1 = get_daily_sleep()
hourly_steps1 = get_hourly_steps()
weight_info1 = get_weight_info()
heartrate_seconds1 = get_heartrate_seconds()
daily_steps1 = get_daily_steps()
heart_df1=get_heart()
daily_activity = daily_activity1.copy()
daily_sleep = daily_sleep1.copy()
hourly_steps = hourly_steps1.copy()
weight_info = weight_info1.copy()
heartrate_seconds = heartrate_seconds1.copy()
daily_steps = daily_steps1.copy()
heart_df=heart_df1.copy()
with head1:
    st.header("About the data")
    st.write("""
    This Kaggle data set
    contains personal fitness tracker data from thirty fitbit users. This dataset generated by respondents to a distributed survey via Amazon Mechanical Turk between 03.12.2016-05.12.2016. Thirty eligible Fitbit users consented to the submission of personal tracker data, including minute-level output for physical activity, heart rate, and sleep monitoring. Variation between output represents use of different types of Fitbit trackers and individual tracking behaviors / preferences.
    It includes information about daily, hourly and minute activity, steps, and heart rate that can be used to explore usersâ€™ habits.

    Data is stored in multiple CSV files, according to the frequency and type of the collected information.

    """)

    st.write("""### Major Case study goals""")

    st.write("""
    * For how long do users wear their product every day? How many of theese hours are spend on activitiy?
    * On what days of the week and hours of the day are users more active?
    * Does the amount of activity affect heart rate at night and time spent in bed being awake?
    * How does users' BMI affect amount of calories burned?
    """)

    st.header("Data Input")

    tab1, tab2, tab3,tab4,tab5,tab6 = st.tabs(["Daily Activity", "Daily Sleep", "Hourly Steps","Weight Info","Heartrate Seconds","Daily Steps"])

    with tab1:
        st.header("Daily Activity")
        st.dataframe(pd.DataFrame(daily_activity))
        get_info(daily_activity)
   

    with tab2:
        st.header("Daily Sleep")
        st.dataframe(pd.DataFrame(daily_sleep))
        get_info(daily_sleep)


    with tab3:
        st.header("Hourly Steps")
        st.dataframe(pd.DataFrame(hourly_steps))
        get_info(hourly_steps)

    with tab4:
        st.header("Weight Info")
        st.dataframe(pd.DataFrame(weight_info))
        get_info(weight_info)

    with tab5:
        st.header("Heartrate Seconds")
        st.dataframe(pd.DataFrame(heartrate_seconds))
        get_info(heartrate_seconds)

    with tab6:
        st.header("Daily Steps")
        st.dataframe(pd.DataFrame(daily_steps))
        get_info(daily_steps)

with head2:
    st.write("""## Data Exploration using Visualizations""")
    st.write("""Data analysis using graphs and charts prove to be very useful to look at your data. 
    We shall be using Matplotlib and Seaborn for our analysis.""")



    st.write("""### Histograms""")
    st.write("""Let's start by using histograms to see if the data follows a particular kind of distribution. Since we have a lot of features, let's extract a subset for our analysis.""")
    df1 = daily_activity[['TotalSteps','TotalDistance','VeryActiveDistance','ModeratelyActiveDistance','LightActiveDistance','VeryActiveMinutes','FairlyActiveMinutes','SedentaryMinutes','Calories']]
    import warnings    
    
    def histogram_csv():
        warnings.filterwarnings('ignore') 
        plt.subplots(figsize = (30,10))
        df1.hist(figsize=(20,20), bins = 10, xlabelsize=15, ylabelsize= 15)
        st.set_option('deprecation.showPyplotGlobalUse', False)
        st.pyplot() 
    # histogram_csv()
    st.image('histogram_img.png')
    st.write("""As seen from the above plots, a few of the variables  follows a normal distribution. It would be interesting to carry out some form of hypothesis testing as well if the distributions behave the same on both weekdays and weekends or there would be a significant difference between them.""")

    st.write("""### Scatter plots""")
    st.write("""Since most of the variables in our dataset are numerical, it would be interesting to plot scatter plots and see how the variables interact with one another.""")

    def pairplot():
        pplot = ['TotalSteps','TotalDistance','TrackerDistance','VeryActiveDistance','ModeratelyActiveDistance','LightActiveDistance',
                'VeryActiveMinutes','FairlyActiveMinutes','LightlyActiveMinutes','SedentaryMinutes','Calories']
        sns.set()
        fig=sns.pairplot(daily_activity[pplot], kind = 'reg')
        st.pyplot(fig)

    st.image('pairplot_daily_activity.png')

    st.write("""Regression plots serve as a better tool because along with the scatter plots, we get a best fit line which shows the trend of the data points. Also, if we see that this trend line passes through majority of the points, we can assume that we can use this data for a good predictive model as well.""")
        
    st.write("""Some of the notable insights from the above plots are:  
        Calories Burned is directly related to  the distance . This means
        the more a person stays active, the more calories they burn, which ultimately results in a lower RHB.  
        Heart beat is highly correlated to 'Minutes Sedentary'.""")
    st.write("### Correlation Plots and Matrix")
    st.dataframe(df1.corr())
    st.write("A correlation matrix allows one to see the relationship between different numerical variables at a glance. We can also find the correlation for a single variable of interest. For e.g:")


    def corr_plot():
        corrp = df1.corr()
        fig, ax = plt.subplots(figsize=(20,20))
        ax=sns.heatmap(corrp, annot= True, robust=True,annot_kws= {"size" : 18},cmap='viridis',square= True,ax=ax)
        return fig
    # fig_corr_plot=corr_plot()
    # st.write(fig_corr_plot)
    st.image('correlation_matrix.png')
    st.write("""### Box-Plots""")
    st.write("""Box plots help us to combine both numerical and categorical variables and understand how they relate to each other. The best thing about using box plots is that we can directly get an understanding of our data distribution (the mean, the spread, left/right skewed etc).""")

    def box_plot():
        fig, ax = plt.subplots(figsize = (30,10))
        # st.write("Function Ran")
        # plt.figure(figsize = (30,10))
        ax = sns.boxplot(x = 'ActivityDay', y = 'StepTotal', data = daily_steps)
        return fig
    # fig_box_plot=box_plot()
    # st.pyplot(fig_box_plot)
    st.image('box_plot.png')
    st.write("It is also very important to understand how many unique users participated in data collection for each dataset:")
    st.write("activity:", daily_activity["Id"].nunique())
    st.write("sleep:", daily_sleep["Id"].nunique())
    st.write("weight:", weight_info["Id"].nunique())
    st.write("heart rate:", heartrate_seconds["Id"].nunique())

    st.write("The amount of unique participants for **weight** category is very limited. To draw reliable conclusions, deeper analysis is needed.")
with head3:
    st.write("# Cleaning and Processing")
    st.write("### Formatting")
    daily_sleep['SleepDay'] = pd.to_datetime(daily_sleep['SleepDay']).dt.date
    daily_activity['ActivityDate'] = pd.to_datetime(daily_activity['ActivityDate']).dt.date
    weight_info['Date'] = pd.to_datetime(weight_info['Date']).dt.date
    hourly_steps['ActivityHour'] = pd.to_datetime(hourly_steps['ActivityHour']).dt.hour
    tab1, tab2, tab3,tab4 = st.tabs(["Daily Activity", "Daily Sleep", "Hourly Steps","Weight Info"])
    with tab1:
        st.header("Daily Activity")
        st.dataframe(daily_activity['ActivityDate'])
    with tab2:
        st.header("Daily Sleep")
        st.dataframe(daily_sleep['SleepDay'])
    with tab3:
        st.header("Hourly Steps")
        st.dataframe(hourly_steps['ActivityHour'])
    with tab4:
        st.header("Weight Info")
        st.dataframe(weight_info['Date'])


    st.write("### Merging")
    st.write("""Now all the daily data containing information about activity and sleep can be merged into single dataset to make data manipulation and analysis easier.""")

    daily_data = pd.merge(daily_activity, daily_sleep, how = "left", left_on=["Id", "ActivityDate"], right_on=["Id", "SleepDay"])
    daily_data.rename({"ActivityDate":"Date"}, axis=1, inplace=True)
    # daily_data.head()
    st.dataframe(daily_data)
with head4:
    st.write("# Analysis and Visualizations")
    st.write("### Active and wear time")
    st.write("Users active time and wear time can be calculated using minutes spent on each activity type.")

    daily_data['ActiveTime'] = daily_data['VeryActiveMinutes'] + daily_data['FairlyActiveMinutes'] + daily_data['LightlyActiveMinutes']
    daily_data['WearTime'] = daily_data['ActiveTime'] + daily_data['SedentaryMinutes']

    st.write("Group the daily data by user Id to get average numbers in each observation category:")

    id_avg = daily_data.groupby(by='Id', as_index=False).mean()
    # id_avg.head()
    st.dataframe(id_avg)
    st.header("Active time per day")
    def active_time_per_day():
        fig, x = plt.subplots()
        x.set_title("Active time per day")
        x.set_xlabel("Hours")
        x.set_ylabel("Observations")
        x=(daily_data['ActiveTime']/60).hist(bins=40, width=0.2)
        st.pyplot(fig)
        # plt.title('Active time per day', fontweight="bold", fontsize=20)
        # plt.ylabel('Observations')
        # plt.xlabel('Hours')
        # plt.show()
        st.write("Average active time: ", round(id_avg['ActiveTime'].mean()/60,1), "hours")
    # active_time_per_day()
    st.image('active_time_per_day.png')
    st.write("""As shown on the histogram, users' active time per day ranges from 0 up to 9 hours, with most people being active 3-6 hours a day. There is also a large amount of observations with users having 0 recorded hours of activity. It can be explain by the fact that users sometimes forget to wear their devices or leave them to charge during the day. Fitbit can use this insight and remind users to wear their devices during the day and charge them on time.""")
    def wear_time_per_day():
        fig, x = plt.subplots()
        x.set_title("Wear time per day")
        x.set_xlabel("Hours")
        x.set_ylabel("Observations")
        x=(daily_data['WearTime']/60).hist(bins=40, width=0.5)
        st.pyplot(fig)
        # plt.title('Wear time per day', fontweight="bold", fontsize=20)
        # plt.ylabel('Observations')
        # plt.xlabel('Hours')
        # plt.show()
        st.write("Average wear time:", round(id_avg['WearTime'].mean()/60,1), "hours")
    st.header("Wear time per day")
    # wear_time_per_day()
    st.image('wear_time_per_day.png')
    st.write("Wear time distribution shows that most of the times users wear their devices all day, with average wear time being 20.4 hours.")

    def wear_time_distribution():

        type_1 = daily_data['WearTime'][daily_data.WearTime==1440].count()
        type_2 = daily_data['WearTime'][(daily_data.WearTime<1440) & (daily_data.WearTime>720)].count()
        type_3 = daily_data['WearTime'][daily_data.WearTime<720].count()

        labels = ['All day', 'More than half day', 'Less than half day']
        sizes = [type_1, type_2, type_3]

        fig1, ax1 = plt.subplots()
        ax1.pie(sizes, labels=labels, autopct='%1.1f%%', shadow=True, startangle=90)
        ax1.axis('equal')

        st.pyplot(fig1)
    # wear_time_distribution()
    st.image('avg_wear_time.png')

    st.write("### Activity distribution")
    st.write("On which weekdays are users are more active? :")
    def avg_steps_per_weekday():
        daily_data['WeekdayName'] = pd.to_datetime(daily_data['Date']).dt.day_name()
        daily_data['Weekday'] = pd.to_datetime(daily_data['Date']).dt.weekday

        weekday_steps = daily_data[['WeekdayName','Weekday','TotalSteps']].groupby(by=['Weekday', 'WeekdayName'], as_index=False).mean()
        weekday_steps.head()

        fig = plt.figure()
        ax = fig.add_axes([0,0,1,1])
        ax.bar(weekday_steps['WeekdayName'],weekday_steps['TotalSteps'])
        plt.axhline(y=weekday_steps['TotalSteps'].mean(), color='r', linestyle='--')
        ax.set_title('Average number of steps per weekday', fontweight="bold", fontsize=20)
        ax.set_ylabel('Steps')
        # plt.show()
        st.pyplot(fig)
    # avg_steps_per_weekday()
    st.image('avg_steps_per_weekday.png')
    st.write("Tuesday and Saturday are the most active days, while on Sunday participants were least active. FitBit can use this insight and motivate people to do excercises consistently.")

    hourly_steps_avg = hourly_steps[['ActivityHour', 'StepTotal']].groupby(by=['ActivityHour'], as_index=False).mean()
    hourly_steps_avg.rename(columns={'StepTotal':'AverageSteps'}, inplace = True)
    def avd_steps_hourly():
        # hourly_steps_avg = hourly_steps[['ActivityHour', 'StepTotal']].groupby(by=['ActivityHour'], as_index=False).mean()
        # hourly_steps_avg.rename(columns={'StepTotal':'AverageSteps'}, inplace = True)
        # hourly_steps_avg.head()
        st.dataframe(hourly_steps_avg)

        fig = plt.figure()
        ax = fig.add_axes([0,0,1,1])
        ax.set_title('Average number of steps per hour', fontweight="bold", fontsize=20)
        ax.set_ylabel('Steps')
        ax.set_xlabel('Hour of the day')
        ax.bar(hourly_steps_avg['ActivityHour'],hourly_steps_avg['AverageSteps'])
        # plt.show()
        st.pyplot(fig)
    # avd_steps_hourly()
    st.image('avg_steps_per_hour.png')
    st.write("FitBit tracks users to making most steps starting around **8 a.m.** and keep it up until **8 p.m.**. There are also much less steps being made around 3 p.m., which can be explain by people having lunch break around that time.")

    st.write("### Night-time heart rate")

    st.write("The amount of activity that a user does on average affects heart rate at night and time spent in bed being awake. For that purpose, calculate average heart rate for each user at the least active time (the night hour with the minimal number of steps being made on average).")
    def heart_rate_avg():
        min_steps_hour = hourly_steps_avg['AverageSteps'].idxmin()

        heartrate_seconds['Hour'] = pd.to_datetime(heartrate_seconds['Time']).dt.hour
        heartrate_night = heartrate_seconds[heartrate_seconds.Hour == min_steps_hour][['Id','Value']]

        heartrate_night_avg = heartrate_night.groupby(by='Id').mean()
        heartrate_night_avg = pd.merge(id_avg[['Id', 'TotalSteps', 'Calories', 'ActiveTime']], heartrate_night_avg['Value'], how='right', on='Id')

        heartrate_night_avg.rename(columns={'Value':'HeartRateAvg'}, inplace=True)

    # heartrate_night_avg=pd.read_csv('heartrate_night_avg.csv')
    # st.dataframe(heartrate_night_avg)

    # def avg_heart_rate_at_night():
    #     fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(20, 5))
    #     fig.suptitle('Average heart rate at night', fontweight="bold", fontsize=20)

    #     # Total Steps
    #     z = np.polyfit(heartrate_night_avg['TotalSteps'], heartrate_night_avg['HeartRateAvg'], 1)
    #     p = np.poly1d(z)
    #     ax1.plot(heartrate_night_avg['TotalSteps'], p(heartrate_night_avg['TotalSteps']), "r-", alpha=0.5)
    #     ax1.scatter(heartrate_night_avg['TotalSteps'], heartrate_night_avg['HeartRateAvg'])

    #     # Calories
    #     z = np.polyfit(heartrate_night_avg['Calories'], heartrate_night_avg['HeartRateAvg'], 1)
    #     p = np.poly1d(z)
    #     ax2.plot(heartrate_night_avg['Calories'], p(heartrate_night_avg['Calories']), "r-", alpha=0.5)
    #     ax2.scatter(heartrate_night_avg['Calories'], heartrate_night_avg['HeartRateAvg'])

    #     # Active Time
    #     z = np.polyfit(heartrate_night_avg['ActiveTime'], heartrate_night_avg['HeartRateAvg'], 1)
    #     p = np.poly1d(z)
    #     ax3.plot(heartrate_night_avg['ActiveTime'], p(heartrate_night_avg['ActiveTime']), "r-", alpha=0.5)
    #     ax3.scatter(heartrate_night_avg['ActiveTime'], heartrate_night_avg['HeartRateAvg'])

    #     ax1.set_ylabel('Heart Rate', fontweight='bold')
    #     ax1.set_xlabel('Total Steps', fontweight='bold')
    #     ax2.set_xlabel('Calories', fontweight='bold')
    #     ax3.set_xlabel('Active Time', fontweight='bold')

    #     st.pyplot(fig)
    # avg_heart_rate_at_night()
    st.image('avg_heart_rate_at_night.png')
    st.write("As we can see, there is little to no correlation between heart rate at night and the average amount of steps or active time. However, **there is negative correlation between te amount of calories being burned on average and the heart rate at night**.Since there are only 14 participants that submitted their heart rate data, so deeper investigation to prove the correlation is recommended.")


    st.write("### Time awake in bed")

    def time_awake_in_bed():
        daily_data['InBedAwakeMinutes'] = daily_data['TotalTimeInBed'] - daily_data['TotalMinutesAsleep']
        daily_data['InBedAwakeMinutes'] = daily_data['InBedAwakeMinutes'].astype(float)

        fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(20, 5))
        fig.suptitle('Time spent awake in bed', fontweight="bold", fontsize=20)
        ax1.scatter(daily_data['TotalSteps'],daily_data['InBedAwakeMinutes'])
        ax2.scatter(daily_data['Calories'],daily_data['InBedAwakeMinutes'])
        ax3.scatter(daily_data['ActiveTime'],daily_data['InBedAwakeMinutes'])

        ax1.set_ylabel('Minutes Awake', fontweight='bold')
        ax1.set_xlabel('Total Steps', fontweight='bold')
        ax2.set_xlabel('Calories', fontweight='bold')
        ax3.set_xlabel('Active Time', fontweight='bold')

        st.pyplot(fig)
    # time_awake_in_bed() 
    st.image('time_spent_awake_in_bed.png')
    st.write("There is little to no correlation between users' activity and their time spent awake in bed. **In most cases, participants spent less than 2 hours a day being awake in bed**. There are several outliers, which can be explained by people having insomia or spending more time in bed during weekends or due to illness.")

    st.write("### BMI and burned calories")
    st.write("To explore the relationships between these two properties use **calories burned on average per 100 steps** as a metric.")


    calories_burned = daily_data[['Id','TotalSteps','Calories']].groupby(by='Id',as_index=False).mean()
    calories_burned['CaloriesPer100Steps'] = calories_burned['Calories']/(calories_burned['TotalSteps']/100)

    st.write("Calculating average BMI for each participant and merging data")

    BMI_data = weight_info.groupby(by='Id', as_index=False).mean()
    calories_BMI = calories_burned.merge(BMI_data[['Id','BMI']], how='right')

    def bmi_calories_burned():
        fig, ax = plt.subplots()
        ax=plt.scatter(calories_BMI['BMI'],calories_BMI['CaloriesPer100Steps'])
        z = np.polyfit(calories_BMI['BMI'], calories_BMI['CaloriesPer100Steps'], 1)
        p = np.poly1d(z)
        plt.plot(calories_BMI['BMI'], p(calories_BMI['BMI']), linewidth=2, color='r', alpha=0.2)
        plt.title('Calories burned per 100 steps for different BMIs', fontweight="bold", fontsize=20)
        plt.xlabel('BMI')
        plt.ylabel('calories per 100 steps')
        # plt.show()
        st.pyplot()
    # bmi_calories_burned()
    st.image('calorie_burned.png')
    st.write("It seems like there is a strong positive correlation, which means people with higher BMI tend to burn more calories for the same activity.")
    # filename = 'database_main.xls'

    # data = pd.read_excel(filename, sheet_name="main", converters= {'Date': pd.to_datetime})
    # data.set_index(pd.to_datetime(data.Date),inplace=True)

    # dayGroupedData = data.groupby(['Day of Week']).mean()
    # dayTypeGroupedData = data.groupby(['Is Weekday']).mean()

    # dayTypeGroupedData
    dayCodes = ['', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
    minDayCodes = ['', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']

    days = {1: 'Mon', 2: 'Tue', 3: 'Wed', 4: 'Thu', 5: 'Fri', 6: 'Sat', 7: 'Sun'}


    # def days_of_the_week():
    #     fig = plt.figure(figsize = (20,6))

    #     ax = plt.subplot(131)  
    #     plt.bar(dayGroupedData.index, dayGroupedData['Steps'])
    #     plt.title('Day of Week vs. Steps', fontsize=15)
    #     plt.xlabel('Day of Week', fontsize=14)
    #     plt.ylabel('Steps', fontsize=14)
    #     ax.axhline(8000, color="orangered", linestyle='--')
    #     ax.axhline(10000, color="orange", linestyle='--')
    #     ax.set_xticklabels(minDayCodes)

    #     #############

    #     ax2 = fig.add_subplot(132)
    #     plt.bar(dayGroupedData.index, dayGroupedData['Calories Burned'], color='blueviolet')
    #     plt.title('Day of Week vs. Calories Burned', fontsize=15)
    #     plt.xlabel('Day of Week', fontsize=14)
    #     plt.ylabel('Calories Burned', fontsize=14)
    #     ax2.set_xticklabels(minDayCodes)

    #     #############

    #     ax3 = fig.add_subplot(133)
    #     ax3.set_xticklabels(minDayCodes)
    #     plt.bar(dayGroupedData.index, dayGroupedData['Minutes Very Active'], color='orange')
    #     plt.title('Day of Week vs. Minutes Very Active', fontsize=15)
    #     plt.xlabel('Day of Week', fontsize=14)
    #     plt.ylabel('Minutes Very Active', fontsize=14)
    #     # plt.show()
    st.subheader("Day of Week Tracking")
    st.image('day_of_week.png')
    st.write("The graphs above suggest that the average is about 7800 steps per day.There are some studies which suggest hitting 10000 steps per day is ideal.Tuesdays to Saturdays were the days where the average was about 40 minutes of very active minutes - which simply translates to active exercise. Fewer minutes on Sundays could be purely due to laziness/recovery time. The drop in active minutes on Mondays could be due to the Monday Blues which is an obvious trend observed.")
    # def cal_burned_for_various_activities():
    #     activityDf = pd.read_excel(filename, sheet_name="activities")
    #     #skateboard,badminton, body weight ex, cyclinng
    #     activityDf['Cal/Min'] = activityDf['Calories burned']/activityDf['Time']
    #     groupedActivitiesDf = activityDf.groupby(['Activity Type']).mean()

    #     #Plot Data
    #     plt.barh(groupedActivitiesDf.index, groupedActivitiesDf['Cal/Min'], color='seagreen')
    #     plt.title('Calories burned per minutes for various Activities')
    #     plt.xlabel('Cal/Min')
    #     plt.plot()
    st.subheader("Calories burned in various activities")
    st.image("cal_burned_various_activities.png")
    st.write("""Analysing the amount of calories burned per minutes for various Activities shows the above graph formed.It can be inferred that running helps burn almost 12 calories per minute.Tennis : one of the favourite activities from the lotâ€Š, takes the second spot.Swimming numbers are not shocking as the exercise turns out to be a leisure activity.""")

    st.write("""## Sleep on various days of the week using box-plot""")
    st.image("sleep_various_days_of_week.png")
with head5:
    st.write("# Conclusions and Recommendations")

    st.markdown("""Here are the key takeaways from the performed analysis:""")
    st.markdown("""
    1. Average user's active time per day:  **3.8 hours**. Average user's wear time per day: **20.4 hours**. There is also a large amount of observations with users having 0 recorded hours of activity.

        *Recommendation*: FitBit can remind users to wear their devices during the day and charge them on time.
    2. *Tuesday and Saturday* are the **most** active days, while on *Sunday* participants were **least** active.

        *Recommendation*: FitBit can motivate people to do excercises consistently throughout the week.
    3. Fitness trackers users make most steps starting around **8 a.m.** and keep it up until **8 p.m.**. There are also much less steps being made around 3 p.m., which can be explain by people having lunch break around that time.

    4. There is **little to no correlation** between *heart rate at night* and the *average amount of steps or active time*. However, there is **negative correlation** between the *amount of calories being burned on average* and *the heart rate at night*. Further analysis recommended due to limited data entries.

    5. Users mostly spend **2 hours per day** being awake in bed. There is **little to no correlation** between *users' activity* and their *time spent awake in bed*.

        *Recommendation*: FitBit can remind users to wake up if they lay in a bed for too long, or promote healthy sleep habits if consistent sleep problems were found. 

    6. Users with higher BMI tend to **burn more calories** for the same activity. Further analysis recommended due to limited data entries.""")
with head7:
    st.subheader("Heart Disease Prediction")
    heart_df = heart_df[heart_df['RestingBP'] > 0]
    heart_df = heart_df[heart_df['Cholesterol'] > 0]
    heart_df = heart_df[heart_df['Oldpeak'] >= 0]
    df_dummies = heart_df.copy()
    df_label = heart_df.copy()
    df_dummies = pd.get_dummies(df_dummies)
    for i in df_label.select_dtypes('object').columns:
        le = LabelEncoder()
        df_label[i] = le.fit_transform(df_label[i])
    X_dummies = df_dummies.drop(['HeartDisease','Oldpeak','ST_Slope_Down','ST_Slope_Flat','ST_Slope_Up'], axis=1)
    # st.table(X_dummies)
    y_dummies = df_dummies['HeartDisease'].values
    X_dummies = SelectKBest(chi2, k=15).fit_transform(X_dummies, y_dummies)
    X_dummies = StandardScaler().fit_transform(X_dummies)

    X_label = df_label.drop(['HeartDisease'], axis=1).values
    y_label = df_label['HeartDisease'].values
    X_label = SelectKBest(chi2, k=4).fit_transform(X_label, y_label)
    X_label = RobustScaler().fit_transform(X_label)
    # X_dummies.drop([''])
    X_train, X_test, y_train, y_test = train_test_split(X_dummies, y_dummies, random_state= 5, test_size=0.25)
    knn_model = Knn(algorithm= 'auto', n_neighbors= 17, p= 2, weights= 'distance') #euclidean_distance 
    knn_model.fit(X_train, y_train)
    # y_pred = knn_model.predict(X_test)
    # st.dataframe(y_pred)
    col1,col2,col3=st.columns(3)
    with col1:

        # Age	RestingBP	Cholesterol	FastingBS	
        # MaxHR	Oldpeak	HeartDisease	Sex_F	Sex_M	
        # ChestPainType_ASY	...	ChestPainType_NAP	ChestPainType_TA	
        # RestingECG_LVH	RestingECG_Normal	RestingECG_ST	ExerciseAngina_N	ExerciseAngina_Y	ST_Slope_Down	ST_Slope_Flat	ST_Slope_Up
        Age=st.text_input('Age')
        FastingBS=st.selectbox('Fasting Blood Sugar',['Yes','No'])
        ExerciseAngina=st.selectbox('Excercise Anigma',['Yes','No'])
    with col2:
        Sex=st.selectbox('Gender',['Male','Female','Other'])
        RestingBP=st.text_input('Resting Blood Pressure')
        MaxHR=st.text_input('Max Heart Rate')
    with col3:
        Cholesterol=st.text_input('Cholesterol')
        ChestPainType=st.selectbox('Chest Pain Type',['ASY','ATA','NAP','TA'])
        RestingECG=st.selectbox('Resting ECG',['Normal','ST','LVH'])
    ExerciseAngina_N=0
    ExerciseAngina_Y=0
    if ExerciseAngina=="Yes":
        ExerciseAngina_N=1
    else:
        ExerciseAngina_Y=1
    ChestPainType_ASY=0
    ChestPainType_NAP=0
    ChestPainType_TA=0
    ChestPainType_ATA=0
    Sex_M=0
    Sex_F=0
    if Sex=='Male':
        Sex_M=1
    else:
        Sex_F=1
    if ChestPainType=='ASY':
        ChestPainType_ASY=1
    if ChestPainType=='ATA':
        ChestPainType_ATA=1
    elif ChestPainType=='NAP':
        ChestPainType_NAP=1
    elif ChestPainType=='TA':
        ChestPainType_TA=1
    RestingECG_LVH=0
    RestingECG_Normal=0
    RestingECG_ST=0
    if RestingECG=='Normal':
        RestingECG_LVH=1
    elif RestingECG=='Normal':
        RestingECG_Normal=1
    elif RestingECG=='Normal':
        RestingECG_ST=1
    # print(Age)
    FBS=0
    if FastingBS=='Yes':
        FBS=1
    else:
        FBS=0
    # print(type(int(Age)))#type(int(FastingBS)),type(int(ExerciseAngina),type(int(Sex)),type(int(RestingBP)),type(int(MaxHR)),type(int(Cholesterol)),type(int(ChestPainType)),type(int(RestingECG))))
    # print([int(Age),int(RestingBP),int(Cholesterol),int(FastingBS),int(MaxHR),Sex_F,Sex_M,ChestPainType_ASY,ChestPainType_NAP,ChestPainType_TA,RestingECG_LVH,RestingECG_Normal,RestingECG_ST,ExerciseAngina_N,ExerciseAngina_Y])
    # y_p= knn_model.predict(pd.DataFrame([[float(Age),float(RestingBP),float(Cholesterol),float(FastingBS),float(MaxHR),Sex_F,Sex_M,ChestPainType_ASY,ChestPainType_NAP,ChestPainType_TA,RestingECG_LVH,RestingECG_Normal,RestingECG_ST,ExerciseAngina_N,ExerciseAngina_Y]]).values)
    if st.button('Predict Results'):
        y_p=knn_model.predict(pd.DataFrame([[float(Age),float(RestingBP),float(Cholesterol),float(FBS),float(MaxHR),Sex_F,Sex_M,ChestPainType_ASY,ChestPainType_NAP,ChestPainType_TA,RestingECG_LVH,RestingECG_Normal,RestingECG_ST,ExerciseAngina_N,ExerciseAngina_Y]]).values)
        if y_p==1:
            st.success("Person Has Heart Disease")
        else:
            st.success("Person Does Not Have Heart Disease")
with head6:
    st.subheader("Sleep Score Prediction")
    # Start Time	End Time	overall_score	composition_score	revitalization_score	duration_score	deep_sleep_in_minutes	resting_heart_rate	restlessness
    sleep_data = pd.read_csv('Fitbit_Sleep_JB_041219_010720.csv')
    sleep_data.dropna(subset=['overall_score'], inplace=True)
    feats = sleep_data.columns[2:9]

    X = sleep_data[feats].astype(float)
    X.drop('Number of Awakenings', axis=1, inplace=True)
    y = sleep_data['overall_score']
    X_train, X_valid, y_train, y_valid = train_test_split(X, y, test_size=0.2, random_state=42)
    scaler = MinMaxScaler()
    scaler.fit_transform(X_train)
    scaler.transform(X_valid)
    regressor = LinearRegression()
    mlr = regressor.fit(X_train, y_train)
    # st.dataframe(X_train)
    # y_predict = mlr.predict(X_valid)
    col1,col2 = st.columns(2)
    with col1:
        mins_asleep=st.text_input("Minutes Asleep")
        time_in_bed=st.text_input("Time in Bed")
        mins_light_sleep=st.text_input("Minutes light sleep")
    with col2:
        mins_awake=st.text_input("Minutes Awake")
        mins_REM_sleep=st.text_input("Minutes REM sleep")
        mins_deep_sleep=st.text_input("Minutes deep sleep")
# 481.0000	92.0000	573.0000	100.0000	316.0000	65.0000
# 430.0000	108.0000	538.0000	31.0000	295.0000	104.0000
    # st.dataframe(y_predict)
    if st.button('Predict Sleep Score'):
        y_predict = mlr.predict(pd.DataFrame([[float(mins_asleep),float(mins_awake),float(time_in_bed),float(mins_REM_sleep),float(mins_light_sleep),float(mins_deep_sleep)]]).values)
        st.success("Predicted sleep score is "+str(y_predict[0]))
        if y_predict>=90 and y_predict<=100:
            st.success("Sleep Score is Excellent")
        elif y_predict>=80 and y_predict<=89:
            st.success("Sleep Score is Good")
        elif y_predict>=60 and y_predict<=79:
            st.success("Sleep Score is Fair")
        else:
            st.success("Sleep Score is Poor")
#         Excellent: 90-100.
#           Good: 80-89.
#           Fair: 60-79.
#               Poor: Less than 60.

